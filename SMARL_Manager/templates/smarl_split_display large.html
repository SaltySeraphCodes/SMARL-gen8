{% extends 'overlay_base.html' %}
{% block title %}
Smarl Splits Display
{% endblock %}
{% block content %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/stream_brand.css') }}">
<div id="lapDisplay">
</div>
    <script src="{{ url_for('static', filename='src/smarl_utils.js') }}"></script>
    <script>    
    // Displays the current lap times and splits in real time
    var boardCreated = false;
    
    // Helper function to convert "MM:SS.mmm" to milliseconds (Crucial for minTime logic)
    const timeToMs = (timeStr) => {
        if (!timeStr || timeStr === "--:--.---") return Number.MAX_SAFE_INTEGER;
        const parts = timeStr.split(/[:.]/);
        if (parts.length !== 3) return Number.MAX_SAFE_INTEGER;
        const minutes = parseInt(parts[0]);
        const seconds = parseInt(parts[1]);
        const milliseconds = parseInt(parts[2]);
        return (minutes * 60 * 1000) + (seconds * 1000) + milliseconds;
    };
    
    // Global chart element vars
    var yScale;
    var xScale;
    var chart_area;
    var interactive_chart;
    var chartSettings;
    var lastKnownData = []; // To store previous lap times for delta calculation

    // D3 functions
    function reloadChart(){
        d3.select("#lapDisplay").selectAll("svg").remove();
        reloadGraphic();
    }

    function reloadGraphic(data,minTime){
        drawData(data,minTime);
    }
    
    // Helper function to format gap/delta time (prefixed with + or -)
    function formatGap(gapSeconds) {
        if (gapSeconds === null || isNaN(gapSeconds)) return "--.---";
        
        const sign = gapSeconds >= 0 ? "+" : "";
        const absSeconds = Math.abs(gapSeconds);
        const seconds = Math.floor(absSeconds);
        const milliseconds = Math.round((absSeconds - seconds) * 1000);

        const s = seconds.toString();
        const ms = milliseconds.toString().padStart(3, '0');

        return `${sign}${s}.${ms}`;
    }

    function createBoard(data) {
        boardCreated = true
        
        // Define an area of 1000px wide, centered on a 1920px canvas
        const canvasWidth = 1920;
        const contentWidth = 1000;
        const contentHeight = 850; // Allowing for a good amount of rows
        const marginH = (canvasWidth - contentWidth) / 2; // ~460px margin on each side

        chartSettings = { 
            width: canvasWidth, 
            height: 1080, 
            margin: {left: marginH, right: marginH, top: 20, bottom: (1080-contentHeight)}
        };
        
        // Scales
        xScale = d3.scaleLinear()
            .domain([0, contentWidth]) // Map the 1000px content width
            .range([chartSettings.margin.left, chartSettings.width - chartSettings.margin.right]);

        // Assuming max 16 cars are visible at once (P1-P16)
        const totalCarsVisible = 16; 
        
        yScale = d3.scaleBand()
            .domain(d3.range(1, totalCarsVisible + 1)) // 1 to 16
            .range([chartSettings.margin.top + 60, contentHeight])
            .paddingInner(0.05)
            .paddingOuter(0.05);

        chart_area = d3.select("#lapDisplay").append("svg")
            .attr('width', chartSettings.width)
            .attr('height',chartSettings.height);
            
        interactive_chart = chart_area.append('g');
        
        // Background rect (now covers the new 1000px wide area)
        var bgRect = interactive_chart.append('rect')
        .attr("x", xScale(0))
        .attr('y', chartSettings.margin.top)
        .attr("rx",10)
        .attr('ry',10)
        .attr('width', contentWidth)
        .attr('height', 0)
        .attr('opacity',0)
        .attr('fill','var(--brand-dark-transparent)')
        .transition()
        .attr('height', contentHeight - chartSettings.margin.top)
        .attr("opacity",0.90)
        .duration(SMARL_SETTINGS.TRANSITION_SHORT);
        
        // Header (Centered over the new 1000px content area)
        var header = interactive_chart.append("text")
        .attr('class','headerText')
        .attr("x", xScale(contentWidth / 2))
        .attr("y", -100 )
        .attr("opacity",0)
        .text( "LIVE LAP SPLITS") 
        .attr('text-anchor', 'middle')
        .attr('alignment-baseline', 'central')
        .attr('font-size','45px')
        .attr('fill','var(--brand-text)')
        .transition()
        .attr("y", chartSettings.margin.top + 30)
        .attr("opacity",1)
        .duration(SMARL_SETTINGS.TRANSITION_LONG);

        // Column Labels (Adjusted to new positions)
        const labelY = chartSettings.margin.top + 50;
        
        // P | Name
        interactive_chart.append("text").attr('class','labelText').attr("x", xScale(10)).attr("y", labelY)
            .text("P | RACER").attr('text-anchor', 'start').attr('font-size','18px');
        // LAST LAP
        interactive_chart.append("text").attr('class','labelText').attr("x", xScale(650)).attr("y", labelY)
            .text("LAST LAP").attr('text-anchor', 'middle').attr('font-size','18px');
        // GAP
        interactive_chart.append("text").attr('class','labelText').attr("x", xScale(780)).attr("y", labelY)
            .text("GAP").attr('text-anchor', 'middle').attr('font-size','18px');
        // DELTA
        interactive_chart.append("text").attr('class','labelText').attr("x", xScale(980)).attr("y", labelY)
            .text("SPLIT").attr('text-anchor', 'end').attr('font-size','18px');


        // Separator line
        var sepLine = interactive_chart.append("line")
        .attr('class','sepLine')
        .attr("x1", xScale(0))
        .attr("y1", chartSettings.margin.top + 55)
        .attr("x2", xScale(contentWidth))
        .attr("y2", chartSettings.margin.top + 55)
        .attr('stroke-width',3)
        .attr("stroke",'var(--brand-main)')
        .attr("opacity",0)
        .transition()
        .attr("opacity",1)
        .duration(SMARL_SETTINGS.TRANSITION_LONG);

        drawData(data)
    }
    
    function drawData(data,minTime){
        
        // Only consider the top 16 positions for the Band Scale
        data = data.filter(d => Number(d.pos) <= 16);
        
        // Store current data to calculate deltas in the next frame
        const currentDataMap = new Map(data.map(d => [d.uid, d]));
        
        const getRank = (d) => Number(d.pos);
        const getYPos = (d) => yScale(getRank(d)) || chartSettings.height;
        const getRowHeight = () => yScale.bandwidth() || 40; 
        const halfBand = getRowHeight() / 2;
        
        // --- 1. Background Rects (racerBG) ---
        racerBG = interactive_chart.selectAll(".bgRect.racerData")
        .data(data, function(d) { return d.id; }); 
        
        // EXIT
        racerBG.exit().transition().attr("x", xScale(1000)).attr("opacity",0).duration(SMARL_SETTINGS.TRANSITION_SHORT).remove();

        // ENTER
        const racerBGEnter = racerBG.enter()
        .append("rect")
        .attr("class","bgRect racerData racerEl")
        .attr('rx',3).attr('ry',3)
        .attr("x", xScale(1000))
        .attr('y', getYPos)
        .attr("opacity",0)
        .attr("width", 1000)
        .attr("height", getRowHeight);
        
        // MERGE (Update & Transition)
        racerBGEnter.merge(racerBG)
        .attr("fill", function(d, i) {
            // Alternating background fill
            return i % 2 === 0 ? 'var(--brand-dark-transparent)' : 'var(--brand-dark)';
        })
        .transition()
        .attr('y', getYPos)
        .attr("x",xScale(0))
        .attr("opacity",0.80)
        .duration(SMARL_SETTINGS.TRANSITION_SHORT);


        // --- 2. Position Rects (posRects) - The White Box ---
        posRects = interactive_chart.selectAll(".posRect")
        .data(data, function(d) { return d.id; }); 
        
        const posRectWidth = 40;
        const posRectHeight = getRowHeight() * 0.9;
        const posRectYOffset = (getRowHeight() - posRectHeight) / 2;

        // EXIT
        posRects.exit().transition().attr("x", -100).attr("opacity",0).duration(SMARL_SETTINGS.TRANSITION_SHORT).remove();

        // ENTER
        const posRectsEnter = posRects.enter()
        .append("rect")
        .attr("class","posRect racerEl")
        .attr("rx", 5).attr("ry", 5)
        .attr("x", -100)
        .attr('y', (d) => getYPos(d) + posRectYOffset)
        .attr("width",posRectWidth).attr("height",posRectHeight)
        .attr("fill",'var(--brand-text)').attr("opacity",0);

        // MERGE (Update & Transition)
        posRectsEnter.merge(posRects)
        .transition()
        .attr('y', (d) => getYPos(d) + posRectYOffset) 
        .attr("x", xScale(10)) 
        .attr("opacity",1)
        .duration(SMARL_SETTINGS.TRANSITION_SHORT);
        
        
        // --- 3. Racer Position Text (posText) ---
        posText = interactive_chart.selectAll(".posText")
        .data(data, function(d) { return d.id; }); 

        const posTextX = xScale(10) + posRectWidth / 2;

        // EXIT
        posText.exit().transition().attr("x", -100).attr("opacity",0).duration(SMARL_SETTINGS.TRANSITION_SHORT).remove();

        // ENTER
        const posTextEnter = posText.enter()
        .append('text').attr('class','posText racerEl')
        .attr("x", -100).attr('y', getYPos) 
        .attr('font-size','24px').attr('fill','var(--brand-text-dark)')
        .attr('text-anchor', 'middle').attr('alignment-baseline', 'central').attr("opacity",0);

        // MERGE (Update & Transition)
        posTextEnter.merge(posText)
        .text(function(d){ return d.pos})
        .transition()
        .attr('y',(d) => getYPos(d) + halfBand + 1)
        .attr("x", posTextX) 
        .attr("opacity",1)
        .duration(SMARL_SETTINGS.TRANSITION_SHORT);
        
        
        // --- 4. Racer Name Text (nameText) ---
        nameText = interactive_chart.selectAll(".nameText")
        .data(data, function(d) { return d.id; }); 

        const nameTextX = xScale(70);

        // EXIT
        nameText.exit().transition().attr("x", -100).attr("opacity",0).duration(SMARL_SETTINGS.TRANSITION_SHORT).remove();
        
        // ENTER
        const nameTextEnter = nameText.enter()
        .append('text').attr('class','nameText racerEl headerText')
        .attr("x", -100).attr('y',getYPos)
        .attr("opacity",0).attr('font-size','22px')
        .attr('text-anchor', 'start').attr('alignment-baseline', 'central');

        // MERGE (Update & Transition)
        nameTextEnter.merge(nameText)
        .text(function(d){ return d.name})
        .transition()
        .attr("x", nameTextX)
        .attr('y',(d) => getYPos(d) + halfBand + 1) 
        .attr("opacity",1)
        .duration(SMARL_SETTINGS.TRANSITION_SHORT);
        
        
        // --- 5. Last Lap Time (lastLapText) ---
        lastLapText = interactive_chart.selectAll(".lastLapText")
        .data(data, function(d) { return d.id; }); 

        const lastLapX = xScale(650); 

        // EXIT
        lastLapText.exit().transition().attr("x", xScale(1200)).attr("opacity",0).duration(SMARL_SETTINGS.TRANSITION_SHORT).remove();

        // ENTER
        const lastLapTextEnter = lastLapText.enter()
        .append('text').attr('class','lastLapText racerEl labelText')
        .attr("x", xScale(1200)).attr('y', getYPos)
        .attr("opacity",0).attr('font-size','22px')
        .attr('text-anchor', 'middle').attr('alignment-baseline', 'central');

        // MERGE (Update & Transition)
        lastLapTextEnter.merge(lastLapText)
        .text(function(d){ return d.lastLap})
        .attr('fill',function(d){
            // Color cyan if it's the fastest lap of the race so far
            const currentMs = timeToMs(d.lastLap);
            return currentMs === minTime ? 'var(--brand-accent)' : 'var(--brand-text)'
        })
        .transition()
        .attr("x", lastLapX)
        .attr('y',(d) => getYPos(d) + halfBand + 1) 
        .attr("opacity",1)
        .duration(SMARL_SETTINGS.TRANSITION_SHORT);

        
        // --- 6. Gap Text (gapText) ---
        gapText = interactive_chart.selectAll(".gapText")
        .data(data, function(d) { return d.id; }); 
        
        const gapTextX = xScale(780); 

        // EXIT
        gapText.exit().transition().attr("x", xScale(1200)).attr("opacity",0).duration(SMARL_SETTINGS.TRANSITION_SHORT).remove();

        // ENTER
        const gapTextEnter = gapText.enter()
        .append('text').attr('class','gapText racerEl labelText')
        .attr("x", xScale(1200)).attr('y', getYPos)
        .attr("opacity",0).attr('font-size','22px')
        .attr('text-anchor', 'middle').attr('alignment-baseline', 'central');

        // MERGE (Update & Transition)
        gapTextEnter.merge(gapText)
        .text(function(d){ 
            // The split data now contains the actual time difference, not just the string
            return d.pos == 1 ? "LEADER" : formatGap(Number(d.split));
        }) 
        .attr('fill', 'var(--brand-text)')
        .transition()
        .attr("x", gapTextX)
        .attr('y',(d) => getYPos(d) + halfBand + 1) 
        .attr("opacity",1)
        .duration(SMARL_SETTINGS.TRANSITION_SHORT);


        // --- 7. Delta/Split Time (deltaText) ---
        deltaText = interactive_chart.selectAll(".deltaText")
        .data(data, function(d) { return d.id; }); 
        
        const deltaTextX = xScale(980); // Far right

        // EXIT
        deltaText.exit().transition().attr("x", xScale(1200)).attr("opacity",0).duration(SMARL_SETTINGS.TRANSITION_SHORT).remove();

        // ENTER
        const deltaTextEnter = deltaText.enter()
        .append('text').attr('class','deltaText racerEl labelText')
        .attr("x", xScale(1200)).attr('y', getYPos)
        .attr("opacity",0).attr('font-size','22px')
        .attr('text-anchor', 'end').attr('alignment-baseline', 'central');

        // MERGE (Update & Transition)
        deltaTextEnter.merge(deltaText)
        .text(function(d){
            // Calculate delta against the previous lap's time for this car
            const lastKnownCar = lastKnownData.find(ld => ld.id === d.id);
            if (lastKnownCar && lastKnownCar.lastLap && d.lastLap) {
                const delta = timeToMs(d.lastLap) - timeToMs(lastKnownCar.lastLap);
                // Convert back to seconds for formatGap
                return formatGap(delta / 1000); 
            }
            return "";
        })
        .attr('fill', function(d) {
            const lastKnownCar = lastKnownData.find(ld => ld.id === d.id);
            if (lastKnownCar && lastKnownCar.lastLap && d.lastLap) {
                const delta = timeToMs(d.lastLap) - timeToMs(lastKnownCar.lastLap);
                if (delta < -10) return 'var(--status-racing)'; // Green (Faster)
                if (delta > 10) return 'var(--brand-main)';     // Red (Slower)
            }
            return 'var(--brand-text)'; // White (Neutral/First Lap)
        })
        .transition()
        .attr("x", deltaTextX)
        .attr('y',(d) => getYPos(d) + halfBand + 1) 
        .attr("opacity",1)
        .duration(SMARL_SETTINGS.TRANSITION_SHORT);
        
        // Update the last known data map for the next frame
        lastKnownData = data;
    }

    </script>
    <script> 
        // loads,parses, and calls all chart creation
        var smarl_data  = [] 
       // Helper functions
        function findObjectByKey(array, key, value) {
          for (var i = 0; i < array.length; i++) {
              if (array[i][key] === value) {
                  return array[i];
              }
          }
          return null;
        }
        function findIndexByKey(array, key, value) {
          for (var i = 0; i < array.length; i++) {
              if (array[i][key] === value) {
                  return i;
              }
          }
          return null;
          }
      // SOCKET FUNCTIONS
        var socket = io.connect('http://' + document.domain + ':' + location.port);
        socket.on( 'connect', function() {
          /*socket.emit( 'getSplits', {
            data: 'getSplits'
          } )*/
         
        socket.on( 'raceData', function( data ) {
            //console.log("GOT Splits",data)
            smarl_data = data['live_data']
          if (smarl_data.length > 0 && !boardCreated){
            initialize(smarl_data)
          } else if(smarl_data.length > 0 && boardCreated){
              updateGraphic(smarl_data)
          }else{
              console.log("No data yet??")
          }
        })})
        function initialize(data){
            //updateInterval = setInterval(updateGraphic, 1000);
            createBoard(data);
        }
        function updateGraphic(data){
             // Get fastest lap
            let minMs = Number.MAX_SAFE_INTEGER;
            data.forEach(d => {
                const currentMs = timeToMs(d.lastLap); 
                if (currentMs < minMs) {
                    minMs = currentMs;
                }
            });
            // Do whatever too
            reloadGraphic(data,minMs);
        }
        
        $(document).ready(function() {
            // var data =[{'id': 1, 'pos': "1", 'name': "Bob Ross", 'lastLap': "1.23.456", 'split': "0.000", 'primary_color': "#FF0000", 'secondary_color': "#00FF00"}, {'id': 2, 'pos': "2", 'name': "Lewis Hamilton", 'lastLap': "1.23.457", 'split': "0.001", 'primary_color': "#0000FF", 'secondary_color': "#FFFF00"}, {'id': 3, 'pos': "3", 'name': "Max Verstappen", 'lastLap': "1.24.456", 'split': "1.000", 'primary_color': "#00FFFF", 'secondary_color': "#FF00FF"}]
            // initialize(data);
        });
        </script>

{% endblock %}