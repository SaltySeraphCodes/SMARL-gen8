dofile "Timer.lua" 
dofile "globals.lua"

-- Copyright (c) 2020 SaltySeraph --
-- raceLineLoader.lua 
-- Updated for Gen 8 Pit Lane Support

Loader = class( nil )
Loader.maxChildCount = -1
Loader.maxParentCount = -1
Loader.connectionInput = sm.interactable.connectionType.power + sm.interactable.connectionType.logic
Loader.connectionOutput = sm.interactable.connectionType.power + sm.interactable.connectionType.logic
Loader.colorNormal = sm.color.new( 0xffc0cbff )
Loader.colorHighlight = sm.color.new( 0xffb6c1ff )

-- Local helper functions utilities
function round( value )
	return math.floor( value + 0.5 )
end

function Loader.client_onCreate( self ) 
	self:client_init()
	print("Created Track Loader")
end

function Loader.client_onDestroy(self)
    self:stopVisualization()
end

function Loader.client_init( self ) 
    self.effectChain = {} -- Can hold multiple lists now if needed, or flat list
    self.visualizing = false
    self.showSpeeds = false
    self.showSegments = true
    self.debug = true 

    self.trackName = "unnamed track" 
    self.trackuid = 1234 
    self.scanError = false
    self.errorLocation = nil

    self.useText =  sm.gui.getKeyBinding( "Use", true )
    self.tinkerText = sm.gui.getKeyBinding( "Tinker", true )
    self.onHover = false
	print("Track Loader V2.1 Client Initialized")
end

function Loader.client_onRefresh( self )
	self:client_onDestroy()
	self:client_init()
end

function Loader.server_onCreate(self)
    self:server_init()
end

function Loader.server_init(self)
    self.trackName = "Unnamed"
    self.trackID = 123 
    self.location = sm.shape.getWorldPosition(self.shape)
    self.direction = self.shape:getAt()
    
    -- Saved Track data loading
    local storedTrack = self.storage:load() 
    if storedTrack == nil then 
        print("No previous track data found")
    else 
        print("Loaded track", storedTrack.N)
        self.trackData = storedTrack
        self:sv_loadTrack() -- Apply offset and prepare for world save
    end
end

-- --- VISUALIZATION ---

function Loader.cl_receiveTrackData(self, data)
    -- Receive simple container with raceChain and pitChain
    self:stopVisualization()
    self.effectChain = {} -- flatten for easier management or keep separate?
    
    local function addChainToEffects(chain, color)
        if not chain then return end
        for _, node in ipairs(chain) do
            local effect = self:generateEffect(node.location, color)
            table.insert(self.effectChain, {effect = effect, location = node.location})
        end
    end

    if data.container then
        -- New Structure
        addChainToEffects(data.container.raceChain, sm.color.new("00ff00")) -- Main Track Green
        addChainToEffects(data.container.pitChain, sm.color.new("ff00ff"))  -- Pit Track Purple
        
        -- Fallback for legacy arrays inside container
        if #data.container > 0 then
             addChainToEffects(data.container, sm.color.new("00ff00"))
        end
    elseif data.nodeChain then
        -- Legacy direct list
        addChainToEffects(data.nodeChain, sm.color.new("00ff00"))
    end

    self:showVisualization()
end

function Loader.generateEffect(self, location, color) 
    local effect = sm.effect.createEffect("Loot - GlowItem")
    effect:setParameter("uuid", sm.uuid.new("4a1b886b-913e-4aad-b5b6-6e41b0db23a6"))
    effect:setScale(sm.vec3.new(0,0,0))
    local col = (color or sm.color.new("AFAFAFFF"))
    
    if location then
        effect:setPosition(location)
        effect:setParameter("Color", col)
    end
    return effect
end

function Loader.stopVisualization(self) 
    if self.effectChain then
        for _, v in ipairs(self.effectChain) do
            if v.effect then v.effect:stop() end
        end
    end
    self.effectChain = {}
    self.visualizing = false
end

function Loader.showVisualization(self) 
    for _, v in ipairs(self.effectChain) do
        if v.effect and not v.effect:isPlaying() then
            v.effect:start()
        end
    end
    self.visualizing = true
end

function Loader.updateVisualization(self) 
    -- If moving effects dynamically (not needed for static loader usually)
    -- But if re-offsetting, we might want to update positions here
end

function Loader.hardUpdateVisual(self) 
    self:stopVisualization()
    self:showVisualization()
end

-- --- SERVER LOGIC ---

function Loader.sv_saveTrack(self) 
    -- 1. Load the current live world data (Generated by TrackScanner)
    -- This data likely contains { raceChain = ..., pitChain = ... }
    local worldData = self:sv_loadWorldTrackData(TRACK_DATA_CHANNEL)
    
    if worldData == nil then
        print("Could not find World Track data to save to block")
        return 
    end
    
    -- 2. Store it in the block
    self.trackData = {
        ["N"] = self.trackName,
        ["I"] = self.trackID,
        ["C"] = worldData, -- Store the whole structure
        ["O"] = self.location, -- Origin at time of save
        ["D"] = self.direction -- Direction at time of save
    }
    self.storage:save(self.trackData)
    print("Track Saved to Block Storage")
    self:sv_sendAlert("Track Saved to Block")
end

function Loader.sv_loadTrack(self) 
    -- Loads data FROM BLOCK, applies offset, prepares for World Save
    if self.trackData == nil then
        print("sv load track: Data is Nil")
        return
    end
    
    -- Deep copy the stored data
    local tempContainer = deepcopy(self.trackData.C) 

    -- Calculate offsets
    -- We need to pass the Origin/Dir stored in trackData vs Current Location
    local offsetData = self:calculateOffsetData()
    
    -- Apply offsets to whatever structure exists
    if tempContainer.raceChain or tempContainer.pitChain then
        if tempContainer.raceChain then 
            self:offsetSingleChain(tempContainer.raceChain, offsetData)
        end
        if tempContainer.pitChain then 
            self:offsetSingleChain(tempContainer.pitChain, offsetData)
        end
    else
        -- Legacy Array
        self:offsetSingleChain(tempContainer, offsetData)
    end

    self.nodeChain = tempContainer -- This is now the "Ready to Publish" data
    
    -- Simplify for client visualization (optional, we just send full for now)
    self.network:sendToClients("cl_receiveTrackData", { container = self.nodeChain })
end

function Loader.sv_saveWorldTrackData(self)
    -- Takes the LOADED and OFFSETTED data in this block and writes it to the world
    if self.nodeChain then
        sm.storage.save(TRACK_DATA_CHANNEL, self.nodeChain)
        print("Track (Main + Pit) Saved To World Channel")
        self:sv_sendAlert("Track Loaded to World")
    else
        print("Error: Cannot save nil track data.")
    end
end

function Loader.sv_loadWorldTrackData(self, channel) 
    local data = sm.storage.load(channel)
    if data == nil then
        print("Server did not find track data") 
    else
        print("Found World Track Data")
        return data
    end
end

-- --- OFFSET CALCULATION ---

function Loader.calculateOffsetData(self)
    local originalOrigin = self.trackData.O 
    local originalDirection = self.trackData.D 
    local currentOrigin = self.location      
    local currentDirection = self.direction  
    
    -- 1. Calculate Rotation Difference (Angle around Z-axis)
    local originalAngle = math.atan2(originalDirection.y, originalDirection.x)
    local currentAngle = math.atan2(currentDirection.y, currentDirection.x)
    local radians = currentAngle - originalAngle
    
    -- 2. Calculate Translation Offset is tricky because we rotate around Origin
    -- We process per node in offsetSingleChain
    
    return {
        orig = originalOrigin,
        curr = currentOrigin,
        rads = radians
    }
end

function Loader.offsetSingleChain(self, chain, data)
    if not chain then return end
    
    for k, node in ipairs(chain) do
        -- 1. Center point at saved origin
        local centeredLoc = node.location - data.orig
        local centeredMid = node.mid - data.orig -- Assuming node.mid exists
        
        -- 2. Rotate
        local rotatedLoc = centeredLoc:rotateZ(data.rads)
        local rotatedMid = centeredMid:rotateZ(data.rads)
        
        -- 3. Translate to new origin
        node.location = rotatedLoc + data.curr
        node.mid = rotatedMid + data.curr
        
        -- 4. Rotate vectors
        node.perp = node.perp:rotateZ(data.rads)
        node.outVector = node.outVector:rotateZ(data.rads)
    end
end

-- --- INTERACTION ---

function Loader.sv_sendAlert(self, msg) 
    self.network:sendToClients("cl_showAlert", msg)
end

function Loader.cl_showAlert(self, msg) 
    sm.gui.displayAlertText(msg, 3)
end

function Loader.server_onFixedUpdate(self, timeStep)
    local location = sm.shape.getWorldPosition(self.shape)
    local direction = self.shape:getAt()
    
    if self.trackData ~= nil then
        -- Check for movement to update preview
        if (location ~= self.location or direction ~= self.direction) then
            if sm.shape.getVelocity(self.shape):length() == 0 then
                self.location = location
                self.direction = direction
                self:sv_loadTrack() -- Re-calculate offsets based on new pos
            end
        end
    end
end

function Loader.client_onFixedUpdate( self, timeStep ) 
    self.onHover = cl_checkHover(self.shape)
end

function Loader.client_onUpdate(self, timeStep)
    if self.onHover then 
        sm.gui.setInteractionText( self.useText, "Save World Data to Block", self.tinkerText, "Load Block Data to World", "" )
    end
end

function Loader.client_canTinker( self, character ) return true end

function Loader.client_onTinker( self, character, state )
    -- TINKER = Load from Block -> World (Apply the offset track)
    if state then
        self.network:sendToServer('sv_saveWorldTrackData')
    end
end

function Loader.client_onInteract(self, character, state)
    -- USE = Save from World -> Block (Store current scan)
     if state then
        self.network:sendToServer("sv_saveTrack")
	end
end