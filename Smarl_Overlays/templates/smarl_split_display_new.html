{% extends 'overlay_base.html' %}
{% block title %}
Lap Splits Display
{% endblock %}
{% block content %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/stream_brand.css') }}">
<div id="lapDisplay">
</div>
<script src="{{ url_for('static', filename='src/smarl_utils.js') }}"></script>
<script>
var boardCreated = false;
var initialDrawComplete = false; // Flag to prevent updates during initial animation
var lastKnownData = []; // Store the previous state for delta calculation

// Global chart element vars
var yScale;
var xScale;
var chart_area;
var interactive_chart;
var chartSettings;

// --- Fixed Column Positioning Settings (REORGANIZED) ---
const columnSettings = {
    'pos':     { x: 20, anchor: 'middle', width: 30 }, 
    'tag':     { x: 40, anchor: 'start' },
    'lastLap': { x: 220, anchor: 'end' }, 
    'delta':   { x: 300, anchor: 'end' }, // NEW POSITION for SPLIT
    'gap':     { x: 390, anchor: 'end' }  // NEW POSITION for GAP (Last)
};
const CHART_PADDING = 10;
const CHART_WIDTH = 400; // Increased width for better spacing


// Helper function to format time in "MM:SS.mmm"
function formatTime(totalSeconds) {
    if (totalSeconds === null || isNaN(totalSeconds)) return "--:--.---";
    
    // Assuming incoming data 'lastLap' is already formatted as a string (per comment below)
    if (typeof totalSeconds === 'string') return totalSeconds;

    const minutes = Math.floor(totalSeconds / 60);
    const seconds = Math.floor(totalSeconds % 60);
    const milliseconds = Math.round((totalSeconds - Math.floor(totalSeconds)) * 1000);

    const m = minutes.toString().padStart(2, '0');
    const s = seconds.toString().padStart(2, '0');
    const ms = milliseconds.toString().padStart(3, '0');

    return `${m}:${s}.${ms}`;
}

// Helper function to format gap/delta time (prefixed with + or -)
function formatGap(gapSeconds) {
    if (gapSeconds === null || isNaN(gapSeconds) || Math.abs(gapSeconds) < 0.001) {
        return (gapSeconds === 0) ? "0.000" : "--.---";
    }
    
    const sign = gapSeconds >= 0 ? "+" : "";
    const absSeconds = Math.abs(gapSeconds);
    
    // Format to 3 decimal places
    return `${sign}${absSeconds.toFixed(3)}`;
}

// D3 functions
function reloadChart(){
    d3.select("#lapDisplay").selectAll("svg").remove();
    reloadGraphic();
}

function reloadGraphic(data){
    drawData(data);
}


// Define helper function for color logic (used by colRect)
const getColorAttrs = (d) => {
    const primary = d['primary_color'];
    const tertiary = d['tertiary_color'];
    return {
        fill: (primary.charAt(0) === '#') ? primary : "#" + primary,
        stroke: (tertiary.charAt(0) === '#') ? tertiary : "#" + tertiary
    };
};

// Define helper function for secondary color (used by secondary path)
const getSecondaryFill = (d) => {
    let color = d['secondary_color'];
    return (color.charAt(0) === '#') ? color : "#" + color;
}

function createBoard(data) {
    boardCreated = true;
    totalCars = data.length;
    

    chartSettings = { width: CHART_WIDTH, height: 1100, margin: {left: CHART_PADDING, right:CHART_PADDING, top: 100, bottom:20}} 
    
    //Scales
    xScale = d3.scaleLinear()
        .domain([0, chartSettings.width])
        .range([0, chartSettings.width]);

    const rankData = ["1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16"]
    const ranks = data.map(d => String(d.pos)).slice(0, SMARL_SETTINGS.MAX_CARS); // Use string ranks as domain keys

    yScale = d3.scaleBand() // 53 is a magic number. In reality it should just be the total height of the header + margin.top
        .domain(rankData) 
        .range([chartSettings.margin.top + 60, chartSettings.height - chartSettings.margin.bottom])
        .paddingInner(0.05)
        .paddingOuter(0.05); 


    chart_area = d3.select("#lapDisplay").append("svg")
        .attr('width', chartSettings.width)
        .attr('height',chartSettings.height)
    interactive_chart = chart_area.append('g')
    

    var bgRect = interactive_chart.append('rect')
    .attr("x",0)
    .attr('y',chartSettings.margin.top)
    .attr("rx",8)
    .attr('ry',8)
    .attr('width',chartSettings.width)
    .attr('height',0)
    .attr('opacity',0)
    .attr('fill','var(--brand-dark-transparent)') 
    .transition()
    .attr('height',chartSettings.height)
    .attr("opacity",0.90)
    .duration(SMARL_SETTINGS.TRANSITION_SHORT)

    //Header
    interactive_chart.append("text")
    .attr('class','headerText')
    .attr("x", chartSettings.width/2)
    .attr("y", chartSettings.margin.top + 15)
    .attr("opacity",0)
    .text("LIVE SPLITS")
    .attr('text-anchor', 'middle')
    .attr('alignment-baseline', 'central')
    .attr('font-size','28px')
    .transition()
    .attr("opacity",1)
    .duration(SMARL_SETTINGS.TRANSITION_SHORT)


    // Title labels (Using columnSettings for alignment - REORGANIZED)
const headerLabels = [
    { text: 'P', x: columnSettings.pos.x, anchor: 'middle' },
    { text: 'TAG', x: columnSettings.tag.x, anchor: 'start' },
    { text: 'LAST', x: columnSettings.lastLap.x -10, anchor: 'end' },
    { text: 'SPLIT', x: columnSettings.delta.x -25, anchor: 'middle' }, // SPLIT (DELTA) MOVED
    { text: 'GAP', x: columnSettings.gap.x, anchor: 'end' }      // GAP MOVED LAST
];

    interactive_chart.selectAll(".columnHeader")
        .data(headerLabels)
        .enter()
        .append("text")
        .attr('class','labelText columnHeader')
        .attr("x", d => d.x)
        .attr("y", chartSettings.margin.top + 43)
        .attr("opacity",0)
        .text(d => d.text) 
        .attr('text-anchor', d => d.anchor)
        .attr('alignment-baseline', 'central')
        .attr('font-size','18px')
        .transition()
        .attr("opacity",1)
        .duration(SMARL_SETTINGS.TRANSITION_SHORT)

    // Separator line
    interactive_chart.append("line")
    .attr('class', 'sepLine')
    .attr("x1", CHART_PADDING)
    .attr("y1", chartSettings.margin.top + 59)
    .attr("x2", chartSettings.width - CHART_PADDING)
    .attr("y2", chartSettings.margin.top + 59)
    .attr('stroke-width',3)
    .transition()
    .attr("opacity",1)
    .duration(SMARL_SETTINGS.TRANSITION_SHORT)

    drawData(data)
}


function drawData(data){
    // Filter data to only include cars currently in the D3 domain (P1 - SMARL_SETTINGS.MAX_CARS)
    const filteredData = data.filter(d => yScale.domain().includes(String(d.pos)));

    // Helper accessors
    const getRankKey = (d) => String(d.pos); // D3 scale key is a string
    const getYPos = (d) => yScale(getRankKey(d)) || chartSettings.height;
    const getRowHeight = () => yScale.bandwidth() || 30; 
    const halfBand = getRowHeight() / 2;
    const posBoxWidth = columnSettings.pos.width;
    const posBoxX = columnSettings.pos.x - (posBoxWidth / 2); // Center box around the anchor
    
    // 1. Initialize nextKnownData based on the current filtered data
    //    We only copy the data for racers we *know* are present.
    //    We ensure a clean copy of the current state for the next tick's delta check.
    const nextKnownData = filteredData.map(d => ({ 
        uid: d.uid, 
        lastLap: d.lastLap 
    }));
    
    // --- 1. Background Rects (racerBG) ---
    racerBG = interactive_chart.selectAll(".bgRect.racerData")
    .data(filteredData, function(d) { return d.uid; }) 
    
    // EXIT
    racerBG.exit()
    .transition()
    .attr("x", chartSettings.width + 10)
    .attr("opacity",0)
    .duration(SMARL_SETTINGS.TRANSITION_LONG)
    .remove();

    // ENTER
    const racerBGEnter = racerBG.enter()
    .append("rect")
    .attr("class","bgRect racerData racerEl")
    .attr('rx',3)
    .attr('ry',3)
    .attr("x", chartSettings.width + 10)
    .attr('y', getYPos)
    .attr("opacity",0)
    .attr("width",chartSettings.width - (CHART_PADDING * 2))
    .attr("height",getRowHeight);
    
    // MERGE (Update & Transition)
    racerBGEnter.merge(racerBG)
    .attr("fill", function(d, i) {
            // Alternate colors for readability
    // Use d.pos to determine the index for consistent striping based on rank
    const rankIndex = data.findIndex(item => item.uid === d.uid);
            return rankIndex % 2 === 0 ? 'var(--split-bg-fill)' : 'var(--brand-dark-transparent)';
    })
    .transition()
    .attr('y', getYPos)
    .attr("x",CHART_PADDING)
    .attr("opacity",0.80)
    .duration(SMARL_SETTINGS.TRANSITION_SHORT);

    
    // --- NEW: Racer Positions Background Rect (posRects) ---
    posRects = interactive_chart.selectAll(".posRect")
    .data(filteredData, function(d) { return d.uid; }) 

    // EXIT
    posRects.exit()
    .transition()
    .attr("x", -posBoxWidth) 
    .attr("opacity",0)
    .duration(SMARL_SETTINGS.TRANSITION_SHORT)
    .remove();
    
    // ENTER
    const posRectsEnter = posRects.enter()
    .append("rect")
    .attr("class","posRect racerEl")
    .attr("rx", 5) // Slightly smaller border radius
    .attr("ry", 5)
    .attr("width", posBoxWidth)
    .attr("height", getRowHeight)
    .attr("fill",'var(--brand-text)')
    .attr('stroke','var(--brand-dark)')
    .attr('stroke-width', 2)
    // Initial state: Start far left (outside view)
    .attr("x", posBoxX - posBoxWidth) 
    .attr("y", getYPos)
    .attr("opacity", 0); 

    // MERGE (Apply common updates and final transition)
    posRectsEnter.merge(posRects)
    .transition()
    .duration(SMARL_SETTINGS.TRANSITION_SHORT)
    // Final position for both new and existing elements, using the calculated X for centering
    .attr("x", posBoxX) 
    .attr("y", getYPos)
    .attr("opacity",1);

    // --- 2. Position Text (posText) ---
    posText = interactive_chart.selectAll(".posText")
    .data(filteredData, function(d) { return d.uid; }) 
    
    // EXIT
    posText.exit()
    .transition()
    .attr("x", -50 )
    .attr("opacity",0)
    .duration(SMARL_SETTINGS.TRANSITION_LONG)
    .remove();

    // ENTER
    const posTextEnter = posText.enter()
    .append('text')
    .attr('class','posText racerEl')
    .attr('dy',"0em")
    .attr("x", -50)
    .attr('y', getYPos) 
    .attr('font-size','20px') // Adjusted for smaller box
    .attr('fill','var(--brand-dark)') // Changed to dark to stand out on white box
    .attr('text-anchor', columnSettings.pos.anchor)
    .attr('alignment-baseline', 'central')
    .attr("opacity",0);

    // MERGE (Update & Transition)
    posTextEnter.merge(posText)
    .text(function(d){ return d.pos})
    .transition()
    .attr('y',function(d){
        return getYPos(d) + halfBand + 1;
    }) 
    .attr("x", columnSettings.pos.x) 
    .attr("opacity",1)
    .duration(SMARL_SETTINGS.TRANSITION_SHORT);
    

    
    // ----------------- Racer Primary color rect (Underneath tag?) make tag fill secondary?-----------------
    const colorCol = columnSettings['tag'];
    const colBoxX = columnSettings.tag.x
    const colBoxWidth = 90 // Hard coded for now
    const boxOffset = 4
    colRect = interactive_chart.selectAll(".colRect")
    .data(data, function(d) { return d.uid; }) 

    // 1. EXIT Selection
    colRect.exit()
    .transition()
    .attr("x", -colBoxWidth) 
    .attr("opacity",0)
    .duration(SMARL_SETTINGS.TRANSITION_SHORT)
    .remove();

    // 2. ENTER Selection
    const colRectEnter = colRect.enter()
    .append('rect')
    .attr("class","colRect racerEl")
    .attr("width", colBoxWidth)
    .attr("height", getRowHeight)
    .attr("fill",d => getColorAttrs(d).fill)
    .attr('stroke', d => getColorAttrs(d).stroke)
    .attr('stroke-width', 2)
    // Initial state: Start far left (outside view)
    .attr("x", colBoxX - colBoxWidth) // center it a little better? 
    .attr("y", getYPos)
    .attr("opacity", 0); 
       
    

    // 3. MERGE Selection 
    const colRectMerge = colRectEnter.merge(colRect)
    .attr("fill", d => getColorAttrs(d).fill)
    .attr('stroke', d => getColorAttrs(d).stroke)
    .transition().duration(SMARL_SETTINGS.TRANSITION_SHORT) 
        .attr("x", colBoxX - 4)
        .attr('y',getYPos) 
        .attr("opacity",1); 


    // ----------------- Racer secondary color path -----------------
    var lineGenerator = d3.line()
                // Adjust X: relative to the starting position of the color column
                .x(function(d) {return colBoxX + d[0] + colBoxWidth - triangleWidth - boxOffset }) 
                .y(function(d) { return d[1] });
    
    function triangleGenerator(posY,width,height){
        return [ [0,posY], [width,posY], [width,posY + height]]
    }
    
    const triangleWidth = 60
    const triangleHeight = 30
    secondary = interactive_chart.selectAll(".secondary")
    .data(data, function(d) { return d.uid; }) 

    // 1. EXIT Selection
    secondary.exit()
    .transition()
    .attr("x", posBoxX - posBoxWidth) 
    .attr("opacity",0)
    .duration(SMARL_SETTINGS.TRANSITION_LONG)
    .remove();

    // 2. ENTER Selection
    const secondaryEnter = secondary.enter()
    .append("path")
    .attr("class","secondary racerEl")
    .attr("opacity",0)
    .attr("fill", getSecondaryFill)
    .attr("x", posBoxX + colBoxWidth +triangleWidth) 
    .attr("d", function(d,i) {
        var triangleP = triangleGenerator(yScale(i+1) - 100,triangleWidth,triangleHeight)
        return lineGenerator(triangleP);
    });
    

    // 3. MERGE Selection 
    const secondaryMerge = secondaryEnter.merge(secondary)
    .attr("fill", getSecondaryFill)
    .transition().duration(SMARL_SETTINGS.TRANSITION_SHORT)
    .attr("d", function(d,i) {
        var triangleP = triangleGenerator(yScale(i+1) +1 ,triangleWidth,triangleHeight)
        return lineGenerator(triangleP);
    })
    .attr("opacity",1);


    
    // --- 3. Racer Tag (tagText) ---
    tagText = interactive_chart.selectAll(".tagText")
    .data(filteredData, function(d) { return d.uid; })
    
    // EXIT
    tagText.exit()
    .transition()
    .attr("x", -50)
    .attr("opacity",0)
    .duration(SMARL_SETTINGS.TRANSITION_LONG)
    .remove();

    // ENTER
    const tagTextEnter = tagText.enter()
    .append('text')
    .attr('class','tagText')
    .attr("x", -50)
    .attr("opacity",0)
    .attr('y', getYPos)
    .attr('dy',"0em")
    .attr('font-size','30px')
    .attr('fill','var(--brand-text)')
    .attr('text-anchor', columnSettings.tag.anchor)
    .attr('alignment-baseline', 'central');

    // MERGE (Update & Transition)
    tagTextEnter.merge(tagText)
    .text(function(d){
            // Ensure tag uses the header font for prominence
            //d3.select(this).style("font-family", "var(--brand-font-primary)");
            return d.tag})
    .transition()
    .attr('y', (d) => getYPos(d) + halfBand + 1)
    .attr("x", columnSettings.tag.x )
    .attr("opacity",1)
    .duration(SMARL_SETTINGS.TRANSITION_SHORT);

    
    // --- 4. Last Lap Time (lastLapText) ---
    lastLapText = interactive_chart.selectAll(".lastLapText")
    .data(filteredData, function(d) { return d.uid; })

    // EXIT
    lastLapText.exit()
    .transition()
    .attr("x", chartSettings.width + 10)
    .attr("opacity",0)
    .duration(SMARL_SETTINGS.TRANSITION_LONG)
    .remove();

    // ENTER
    const lastLapTextEnter = lastLapText.enter()
    .append('text')
    .attr('class','lastLapText racerEl')
    .attr("x", chartSettings.width + 10)
    .attr('y', getYPos)
    .attr("opacity",0)
    .attr('dy',"0em")
    .attr('font-size','18px')
    .attr('text-anchor', columnSettings.lastLap.anchor)
    .attr('alignment-baseline', 'central');

    // MERGE (Update & Transition)
    lastLapTextEnter.merge(lastLapText)
    .text(function(d){ return d.lastLap}) // format time here if it's a number
    .attr('fill',function(d){
            // Color sub-accent if last lap is best lap
            return d.lastLap === d.bestLap ? 'var(--brand-sub-accent)' : 'var(--brand-text)'
    })
    .transition()
    .attr('y', (d) => getYPos(d) + halfBand + 1) 
    .attr("x", columnSettings.lastLap.x + 10)
    .attr("opacity",1)
    .duration(SMARL_SETTINGS.TRANSITION_SHORT);


    // --- 5. Delta/Split Time (deltaText) () ---
    deltaText = interactive_chart.selectAll(".deltaText")
    .data(filteredData, function(d) { return d.uid; })
    
    // EXIT
    deltaText.exit()
    .transition()
    .attr("x", chartSettings.width + 10)
    .attr("opacity",0)
    .duration(SMARL_SETTINGS.TRANSITION_LONG)
    .remove();

    // ENTER
    const deltaTextEnter = deltaText.enter()
    .append('text')
    .attr('class','deltaText racerEl')
    .attr("x", chartSettings.width + 10)
    .attr('y', getYPos)
    .attr("opacity",0)
    .attr('dy',"0em")
    .attr('font-size','18px')
    .attr('text-anchor', columnSettings.delta.anchor) // Aligned to the right edge
    .attr('alignment-baseline', 'central');

    // MERGE (Update & Transition)
    deltaTextEnter.merge(deltaText)
    .text(function(d){
            // Calculate delta against the previous lap's time for this car
            // 2. We now search lastKnownData (the previous frame's completed state)
            const lastKnownCar = lastKnownData.find(ld => ld.uid === d.uid);
            
            // Skip delta calculation if we have no history (e.g., first lap)
            if (!lastKnownCar) {
                return "--"; 
            }
            if (lastKnownCar.lastLap && d.lastLap) {
                // Note: Since nextKnownData already contains this racer's current lap time, 
                // the logic to manually update nextKnownData (which was buggy) can be simplified.
                if (d.lastLap !== lastKnownCar.lastLap) {
                    const delta = timeToMs(d.lastLap) - timeToMs(lastKnownCar.lastLap);
                    //const formattedDelta = formatMsToTime(delta)
                    return formatGap(delta/1000);
                } else {
                    return d3.select(this).text(); // Keep previous delta
                }
            }
            return "--"; // Default
    }) 
    .attr('fill', function(d) {
            // Color based on performance (faster is green, slower is red)
            const lastKnownCar = lastKnownData.find(ld => ld.uid === d.uid);
            if (lastKnownCar && lastKnownCar.lastLap && d.lastLap && d.lastLap !== lastKnownCar.lastLap) {
                const delta = timeToMs(d.lastLap) - timeToMs(lastKnownCar.lastLap); 
                if (delta < -0.01) return 'var(--status-racing)'; // Green (Faster)
                if (delta > 0.01) return 'var(--brand-main)'; // Red (Slower)
                
            }
            // Retain the color from the last update if the time hasn't changed
            return d3.select(this).attr('fill') || 'var(--brand-text)'; 
    })
    .transition()
    .attr('y', (d) => getYPos(d) + halfBand + 1) 
    .attr("x", columnSettings.delta.x +10)
    .attr("opacity",1)
    .duration(SMARL_SETTINGS.TRANSITION_SHORT);

    
    // --- 6. Gap to Leader/Next (gapText) ---
    gapText = interactive_chart.selectAll(".gapText")
    .data(filteredData, function(d) { return d.uid; })
    
    // EXIT
    gapText.exit()
    .transition()
    .attr("x", chartSettings.width + 10)
    .attr("opacity",0)
    .duration(SMARL_SETTINGS.TRANSITION_LONG)
    .remove();

    // ENTER
    const gapTextEnter = gapText.enter()
    .append('text')
    .attr('class','gapText racerEl')
    .attr("x", chartSettings.width + 10)
    .attr('y', getYPos)
    .attr("opacity",0)
    .attr('dy',"0em")
    .attr('font-size','18px')
    .attr('text-anchor', columnSettings.gap.anchor)
    .attr('alignment-baseline', 'central');

    // MERGE (Update & Transition)
    gapTextEnter.merge(gapText)
    .text(function(d){ 
            // Use 'Gap to Next' for all but P1 (which is usually Gap to Leader of 0)
            if (Number(d.pos) === 1) return "0.000";
            // Gap to leader is string formatted "0.000"
            return formatGap(d.gapToLeader); 
    }) 
    .attr('fill', 'var(--brand-text)')
    .transition()
    .attr('y', (d) => getYPos(d) + halfBand + 1) 
    .attr("x", columnSettings.gap.x - 5)
    .attr("opacity",1)
    .duration(SMARL_SETTINGS.TRANSITION_SHORT);
    
    // ** FINAL STEP: Update the last known data map for the next frame **
    // The previous critical update logic has been moved to the start.
    lastKnownData = nextKnownData; 
}

</script>
<script> 
var socket = io.connect('http://' + document.domain + ':' + location.port);
socket.on( 'connect', function() {
    socket.emit( 'getRace', { data: 'getRace' } )
})
    
socket.on( 'raceData', function( data ) {
    data = data['realtime_data']
    // Filter and sort the incoming data
    if (!Array.isArray(data)) {
        console.log("Error: realtime_data is missing or not an array.", data);
        return; // Stop processing this bad packet
    }
    let smarl_data = data.filter(function(d,i){return (Number(d.pos) <= SMARL_SETTINGS.MAX_CARS && Number(d.pos) != 0)} )
    smarl_data.sort((a, b) => Number(a.pos) - Number(b.pos)); // Ensure data is sorted by position
    
    if (smarl_data.length > 0 && !boardCreated){
        initialize(smarl_data)
    // Set flag after the initial long entry animation is done
    setTimeout(() => {
        initialDrawComplete = true;
    }, SMARL_SETTINGS.TRANSITION_LONG + 500);
    } else if(smarl_data.length > 0 && boardCreated){
            // Only update if initial draw is complete to avoid visual bugs
    if (initialDrawComplete) {
        updateGraphic(smarl_data)
    }
    }else{
        console.log("No data yet?")
    }
    function initialize(data){
        createBoard(data);
    }
    function updateGraphic(data){
        reloadGraphic(data)
    }
})
</script>

{% endblock %}